#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Utils - OS Utilities Module
===========================
Module centralisant les utilitaires sp√©cifiques au syst√®me d'exploitation
Responsabilit√©s : cr√©ation lanceurs, v√©rifications syst√®me, gestion fichiers temporaires
"""

import os
import sys
import stat
import platform
import subprocess
import logging
import tempfile
import shutil
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
from contextlib import contextmanager


class OSUtils:
    """
    Gestionnaire des utilitaires syst√®me multi-OS
    
    Responsabilit√©s (Single Responsibility Principle) :
    - Cr√©ation et gestion des lanceurs OS-sp√©cifiques
    - V√©rifications de l'environnement syst√®me
    - Gestion des fichiers et dossiers temporaires
    - Utilitaires de compatibilit√© multi-plateforme
    """
    
    # Configuration des lanceurs par OS
    LAUNCHER_CONFIGS = {
        "windows": {
            "filename": "RUN.bat",
            "extension": ".bat",
            "executable_permission": False
        },
        "linux": {
            "filename": "run.sh", 
            "extension": ".sh",
            "executable_permission": True
        },
        "darwin": {  # macOS
            "filename": "run.sh",
            "extension": ".sh", 
            "executable_permission": True
        }
    }
    
    def __init__(self, workspace_root: str = "."):
        """
        Initialise les utilitaires OS
        
        Args:
            workspace_root: R√©pertoire racine de l'application
        """
        self.workspace_root = Path(workspace_root).resolve()
        self.logger = logging.getLogger(__name__)
        self.current_os = self._detect_os()
        self._temp_files: List[Path] = []
        self._temp_dirs: List[Path] = []
    
    def _detect_os(self) -> str:
        """
        D√©tecte le syst√®me d'exploitation actuel
        
        Returns:
            str: 'windows', 'linux', ou 'darwin' (macOS)
        """
        system = platform.system().lower()
        
        # Normalisation pour Windows
        if system == 'windows' or sys.platform.startswith('win'):
            return 'windows'
        elif system == 'darwin':
            return 'darwin'  # macOS
        else:
            return 'linux'  # Par d√©faut pour Unix-like
    
    def get_system_info(self) -> Dict[str, Any]:
        """
        Retourne les informations d√©taill√©es du syst√®me
        
        Returns:
            Dict: Informations syst√®me compl√®tes
        """
        return {
            "os": self.current_os,
            "platform": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "python_version": platform.python_version(),
            "python_executable": sys.executable,
            "workspace_root": str(self.workspace_root)
        }
    
    def check_and_create_launcher(self) -> bool:
        """
        V√©rifie et cr√©e un lanceur OS-sp√©cifique si n√©cessaire
        
        Returns:
            bool: True si un lanceur existe ou a √©t√© cr√©√© avec succ√®s
        """
        try:
            print("üöÄ V√©rification du lanceur syst√®me...")
            
            # Obtenir la configuration pour l'OS actuel
            config = self.LAUNCHER_CONFIGS.get(self.current_os)
            if not config:
                self.logger.warning(f"OS non support√© pour lanceur: {self.current_os}")
                return False
            
            launcher_path = self.workspace_root / config["filename"]
            
            # V√©rifier si le lanceur existe d√©j√†
            if launcher_path.exists():
                print(f"‚úÖ Lanceur existant: {config['filename']}")
                self.logger.info(f"Lanceur OS d√©j√† pr√©sent: {config['filename']}")
                return True
            
            # Cr√©er le lanceur
            print(f"üîß Cr√©ation du lanceur pour {platform.system()}...")
            
            launcher_content = self._generate_launcher_content()
            if not launcher_content:
                return False
            
            # √âcrire le fichier lanceur
            with open(launcher_path, 'w', encoding='utf-8', newline='\\n' if self.current_os != 'windows' else '\\r\\n') as f:
                f.write(launcher_content)
            
            # Appliquer les permissions si n√©cessaire
            if config["executable_permission"]:
                os.chmod(launcher_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)  # 755
            
            os_display_name = {
                'windows': 'Windows',
                'linux': 'Linux', 
                'darwin': 'macOS'
            }.get(self.current_os, self.current_os)
            
            print(f"‚úÖ Lanceur {os_display_name} cr√©√©: {config['filename']}")
            self.logger.info(f"Lanceur {os_display_name} cr√©√© avec succ√®s")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur cr√©ation lanceur: {e}")
            self.logger.error(f"Erreur cr√©ation lanceur: {e}")
            return False
    
    def _generate_launcher_content(self) -> Optional[str]:
        """
        G√©n√®re le contenu du lanceur selon l'OS
        
        Returns:
            str: Contenu du lanceur ou None en cas d'erreur
        """
        try:
            if self.current_os == 'windows':
                return self._generate_windows_launcher()
            else:
                return self._generate_unix_launcher()
        except Exception as e:
            self.logger.error(f"Erreur g√©n√©ration contenu lanceur: {e}")
            return None
    
    def _generate_windows_launcher(self) -> str:
        """G√©n√®re le contenu du lanceur Windows (.bat)"""
        return '''@echo off
REM Lanceur automatique Rob-1 pour Windows
REM G√©n√©r√© automatiquement - Ne pas modifier

echo ================================================
echo üöÄ Lancement de Rob-1
echo ================================================

REM Changer vers le r√©pertoire du script
cd /d "%~dp0"

REM V√©rifier que Python est disponible
python --version >nul 2>nul
if errorlevel 1 (
    echo ‚ùå Python n'est pas install√© ou pas dans le PATH
    echo üí° Veuillez installer Python depuis https://python.org
    echo.
    pause
    exit /b 1
)

REM V√©rifier que main.py existe
if not exist "main.py" (
    echo ‚ùå Fichier main.py introuvable
    echo üìÅ R√©pertoire actuel: %CD%
    echo.
    pause
    exit /b 1
)

REM Afficher les informations de lancement
echo ‚úÖ Python d√©tect√©
echo üìÑ Fichier main.py trouv√©
echo ‚è≥ Lancement de l'application...
echo.

REM Lancer l'application (mode graphique silencieux)
start "Rob-1" /MIN pythonw "main.py"

REM Message de confirmation et fermeture automatique
echo ‚úÖ Application lanc√©e en arri√®re-plan
echo üîÑ Cette fen√™tre va se fermer automatiquement...
timeout /t 2 /nobreak >nul
exit
'''
    
    def _generate_unix_launcher(self) -> str:
        """G√©n√®re le contenu du lanceur Unix (Linux/macOS)"""
        os_name = "macOS" if self.current_os == "darwin" else "Linux"
        
        return f'''#!/bin/bash
# Lanceur automatique Rob-1 pour {os_name}
# G√©n√©r√© automatiquement - Ne pas modifier

echo "================================================"
echo "üöÄ Lancement de Rob-1"
echo "================================================"

# Obtenir le r√©pertoire du script
SCRIPT_DIR="$(dirname "$0")"
cd "$SCRIPT_DIR"

# V√©rifier que Python est disponible
if ! command -v python3 &> /dev/null && ! command -v python &> /dev/null; then
    echo "‚ùå Python n'est pas install√© ou pas dans le PATH"
    echo "üí° Veuillez installer Python depuis votre gestionnaire de paquets"
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..."
    exit 1
fi

# D√©terminer la commande Python √† utiliser
if command -v python3 &> /dev/null; then
    PYTHON_CMD="python3"
else
    PYTHON_CMD="python"
fi

# V√©rifier que main.py existe
if [ ! -f "main.py" ]; then
    echo "‚ùå Fichier main.py introuvable"
    echo "üìÅ R√©pertoire actuel: $(pwd)"
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..."
    exit 1
fi

# Afficher les informations de lancement
echo "‚úÖ Python d√©tect√©: $PYTHON_CMD"
echo "üìÑ Fichier main.py trouv√©"
echo "‚è≥ Lancement de l'application..."
echo ""

# Lancer l'application
$PYTHON_CMD "main.py"

# R√©cup√©rer le code de retour
EXIT_CODE=$?

# Gestion de fermeture
echo ""
if [ $EXIT_CODE -ne 0 ]; then
    echo "‚ùå Erreur lors de l'ex√©cution (code: $EXIT_CODE)"
    echo "üìã V√©rifiez les logs dans system/logs/application.log"
    read -p "Appuyez sur Entr√©e pour continuer..."
else
    echo "‚úÖ Application ferm√©e normalement"
    sleep 1
fi

exit $EXIT_CODE
'''
    
    def verifier_installation_curl(self) -> bool:
        """
        V√©rifie si curl est install√© et accessible dans le syst√®me
        
        Returns:
            bool: True si curl est disponible
        """
        try:
            print("üîç V√©rification de curl...")
            
            result = subprocess.run(
                ['curl', '--version'], 
                capture_output=True, 
                text=True, 
                check=True,
                timeout=10
            )
            
            # Extraire la version de curl
            version_line = result.stdout.split('\\n')[0] if result.stdout else "Version inconnue"
            print(f"‚úÖ Curl disponible: {version_line}")
            self.logger.info(f"Curl disponible: {version_line}")
            
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è Curl install√© mais erreur d'ex√©cution: {e}")
            self.logger.warning(f"Curl erreur d'ex√©cution: {e}")
            return False
        except FileNotFoundError:
            print("‚ö†Ô∏è Curl non trouv√© - Installation recommand√©e pour compatibilit√© maximale")
            self.logger.warning("Curl non disponible dans le PATH")
            return False
        except subprocess.TimeoutExpired:
            print("‚ö†Ô∏è Timeout lors de la v√©rification curl")
            self.logger.warning("Timeout v√©rification curl")
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur v√©rification curl: {e}")
            self.logger.warning(f"Erreur v√©rification curl: {e}")
            return False
    
    @contextmanager
    def create_temp_file(self, suffix: str = "", prefix: str = "rob1_", content: str = ""):
        """
        Gestionnaire de contexte pour fichiers temporaires auto-nettoy√©s
        
        Args:
            suffix: Extension du fichier
            prefix: Pr√©fixe du nom de fichier
            content: Contenu initial du fichier
            
        Yields:
            Path: Chemin vers le fichier temporaire
        """
        temp_file = None
        try:
            # Cr√©er le fichier temporaire
            fd, temp_path = tempfile.mkstemp(suffix=suffix, prefix=prefix, text=True)
            temp_file = Path(temp_path)
            
            # √âcrire le contenu initial si fourni
            if content:
                with os.fdopen(fd, 'w', encoding='utf-8') as f:
                    f.write(content)
            else:
                os.close(fd)
            
            # Enregistrer pour nettoyage
            self._temp_files.append(temp_file)
            
            print(f"üìÅ Fichier temporaire cr√©√©: {temp_file.name}")
            self.logger.debug(f"Fichier temporaire cr√©√©: {temp_path}")
            
            yield temp_file
            
        finally:
            # Nettoyage automatique
            if temp_file and temp_file.exists():
                try:
                    temp_file.unlink()
                    if temp_file in self._temp_files:
                        self._temp_files.remove(temp_file)
                    self.logger.debug(f"Fichier temporaire nettoy√©: {temp_file}")
                except Exception as e:
                    self.logger.warning(f"Erreur nettoyage fichier temporaire: {e}")
    
    @contextmanager
    def create_temp_directory(self, prefix: str = "rob1_"):
        """
        Gestionnaire de contexte pour r√©pertoires temporaires auto-nettoy√©s
        
        Args:
            prefix: Pr√©fixe du nom de r√©pertoire
            
        Yields:
            Path: Chemin vers le r√©pertoire temporaire
        """
        temp_dir = None
        try:
            # Cr√©er le r√©pertoire temporaire
            temp_path = tempfile.mkdtemp(prefix=prefix)
            temp_dir = Path(temp_path)
            
            # Enregistrer pour nettoyage
            self._temp_dirs.append(temp_dir)
            
            print(f"üìÅ R√©pertoire temporaire cr√©√©: {temp_dir.name}")
            self.logger.debug(f"R√©pertoire temporaire cr√©√©: {temp_path}")
            
            yield temp_dir
            
        finally:
            # Nettoyage automatique
            if temp_dir and temp_dir.exists():
                try:
                    shutil.rmtree(temp_dir)
                    if temp_dir in self._temp_dirs:
                        self._temp_dirs.remove(temp_dir)
                    self.logger.debug(f"R√©pertoire temporaire nettoy√©: {temp_dir}")
                except Exception as e:
                    self.logger.warning(f"Erreur nettoyage r√©pertoire temporaire: {e}")
    
    def cleanup_temp_files(self) -> int:
        """
        Nettoie manuellement tous les fichiers temporaires en attente
        
        Returns:
            int: Nombre de fichiers/dossiers nettoy√©s
        """
        cleaned_count = 0
        
        # Nettoyer les fichiers
        for temp_file in self._temp_files.copy():
            try:
                if temp_file.exists():
                    temp_file.unlink()
                    cleaned_count += 1
                self._temp_files.remove(temp_file)
            except Exception as e:
                self.logger.warning(f"Erreur nettoyage fichier {temp_file}: {e}")
        
        # Nettoyer les r√©pertoires
        for temp_dir in self._temp_dirs.copy():
            try:
                if temp_dir.exists():
                    shutil.rmtree(temp_dir)
                    cleaned_count += 1
                self._temp_dirs.remove(temp_dir)
            except Exception as e:
                self.logger.warning(f"Erreur nettoyage r√©pertoire {temp_dir}: {e}")
        
        if cleaned_count > 0:
            print(f"üóëÔ∏è {cleaned_count} fichier(s)/dossier(s) temporaire(s) nettoy√©(s)")
            self.logger.info(f"{cleaned_count} √©l√©ments temporaires nettoy√©s")
        
        return cleaned_count
    
    def get_executable_path(self, executable_name: str) -> Optional[Path]:
        """
        Trouve le chemin complet d'un ex√©cutable dans le PATH
        
        Args:
            executable_name: Nom de l'ex√©cutable √† rechercher
            
        Returns:
            Path: Chemin vers l'ex√©cutable ou None si non trouv√©
        """
        try:
            if self.current_os == 'windows' and not executable_name.endswith('.exe'):
                executable_name += '.exe'
            
            result = subprocess.run(
                ['where' if self.current_os == 'windows' else 'which', executable_name],
                capture_output=True,
                text=True,
                check=True
            )
            
            if result.stdout.strip():
                exe_path = Path(result.stdout.strip().split('\\n')[0])
                self.logger.debug(f"Ex√©cutable trouv√©: {executable_name} -> {exe_path}")
                return exe_path
            
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass
        
        self.logger.debug(f"Ex√©cutable non trouv√©: {executable_name}")
        return None


def main():
    """Point d'entr√©e pour tests standalone"""
    print("üî¨ Test standalone OSUtils")
    print("=" * 35)
    
    # Initialiser OSUtils
    os_utils = OSUtils()
    
    # Afficher les informations syst√®me
    print("üìä Informations syst√®me:")
    system_info = os_utils.get_system_info()
    for key, value in system_info.items():
        print(f"   {key}: {value}")
    
    print()
    
    # Test cr√©ation lanceur
    launcher_created = os_utils.check_and_create_launcher()
    print(f"üöÄ Cr√©ation lanceur: {'‚úÖ OK' if launcher_created else '‚ùå √âchec'}")
    
    # Test v√©rification curl
    curl_available = os_utils.verifier_installation_curl()
    print(f"üîç Curl disponible: {'‚úÖ OK' if curl_available else '‚ö†Ô∏è  Non trouv√©'}")
    
    # Test fichier temporaire
    print("\\nüìÅ Test fichier temporaire:")
    try:
        with os_utils.create_temp_file(suffix=".json", content='{"test": "data"}') as temp_file:
            print(f"   ‚úÖ Fichier temporaire: {temp_file}")
            print(f"   üìÑ Contenu: {temp_file.read_text(encoding='utf-8')}")
        print("   üóëÔ∏è Fichier temporaire auto-nettoy√©")
    except Exception as e:
        print(f"   ‚ùå Erreur test temporaire: {e}")
    
    # Nettoyage final
    cleaned = os_utils.cleanup_temp_files()
    
    print(f"\\n‚úÖ Test OSUtils termin√© - {cleaned} √©l√©ments nettoy√©s")


if __name__ == "__main__":
    main()
